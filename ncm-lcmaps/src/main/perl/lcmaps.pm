# ${license-info}
# ${developer-info}
# ${author-info}
# ${build-info}
#
# Coding style: emulate <TAB> characters with 4 spaces, thanks!
################################################################################


package NCM::Component::lcmaps;

use strict;
use NCM::Component;
use vars qw(@ISA $EC);
@ISA = qw(NCM::Component);
$EC=LC::Exception::Context->new->will_store_all;
use NCM::Check;

use File::Path;

use LC::Check;


##########################################################################
# write a single policy file to path $path
#
##########################################################################

sub WritePolicy($) {

    my ($self , $config) = @_;

    # LCMAPS config file header
        
    my $configdata;
    $configdata="";
    $configdata.="# LCMAPS policy definition\n";
    $configdata.="# Auto-generated by Quattor ncm-lcmaps. DO NOT EDIT.\n";
    $configdata.="#\n";

    if ( $config->{modulepath} ) {
        $configdata.="# default lookup path for modules\n";
        $configdata.="path = $config->{modulepath}\n\n";
    }

    if ( $config->{module} ) {
        for my $modname (keys(%{$config->{module}})) {
            $self->debug(1,"Adding module $modname");
            my $modconfig = $config->{module}->{$modname};
            $configdata .= "$modname = \"$modconfig->{path}\"\n";
            my $ident_len = length($modname) + 7;
            if ( $modconfig->{args} ) {
              # Write one module arg per line for better readability
              my @args = split /\s+(?=-)/, $modconfig->{args};
              for my $arg (@args) {
                next if length($arg) == 0;
                for (my $i=0; $i<$ident_len; $i++) {
                  $configdata .= ' ';                     
                }
                next if length($arg) == 0;
                $configdata.=  ' "' . $arg . "\"\n";                 
              }
            }
            $configdata.="\n";
        }
    }

    # write policies as ordered list
    if ( $config->{policies} ) {
        $configdata.="\n# Policies:\n";

        for my $policy (@{$config->{policies}}) {
            $self->debug(1,"Adding policy $policy->{name}");
	          $configdata.="$policy->{name}:\n";
	          for my $rule (@{$policy->{ruleset}}) {
		          $configdata.= $rule . "\n";
            }
            $configdata.="\n";
        }
    }

    return $configdata;

}


##########################################################################
sub Configure($$@) {
##########################################################################
    
    my ($self, $config) = @_;

    my %cfiles = ();

    # Define paths for convenience. 
    my $base = "/software/components/lcmaps";

    # Load lcmaps configuration into a perl hash
    my $lcmaps_config = $config->getElement($base)->getTree();

    # we will be cautious and only write the set of configuration
    # files if we are entirely successful in generating all of them
    # meanwhile, $cpath{$path} will retain the content
    #
    # Ignore 'multifile' property. Assume it is true when config resource is present.

    my $files;
    if ( $lcmaps_config->{config} ) {
        $self->info("Multi-file configuration for LCMAPS detected");
        $files = $lcmaps_config->{config};
    } else {
        $self->info("Single-file configuration for LCMAPS : $lcmaps_config->{dbpath}");
        $files = [];
        push @{$files}, $lcmaps_config;      
    }
    
    for my $elmt ( @{$files} ) {
        my $dbpath = $elmt->{dbpath};
        $self->info("Processing file $dbpath...");
        $cfiles{$dbpath} = $self->WritePolicy($elmt);
	  }


    # write out all generated policy files

    foreach my $file ( keys %cfiles ) {
        my $result = LC::Check::file($file,
                                     backup => ".old",
                                     contents => $cfiles{$file}
                                    );
        if ( $result < 0 ) {
            $self->log("Failed to update LCMAPS configuration file $file");
        } elsif ( $result == 0 ) {
            $self->debug(1,"LCMAPS configuration file $file up-to-date (no modification)");          
        }
    }

    return 0;
}

1;      # Required for PERL modules

